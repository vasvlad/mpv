diff --git a/video/out/vo_sdl.c b/video/out/vo_sdl.c
index adfcfb43d8..7f365aa09a 100644
--- a/video/out/vo_sdl.c
+++ b/video/out/vo_sdl.c
@@ -29,6 +29,7 @@
 #include <assert.h>
 
 #include <SDL.h>
+#include <SDL_video.h>
 
 #include "input/input.h"
 #include "input/keycodes.h"
@@ -191,6 +192,7 @@ struct priv {
     Uint32 wakeup_event;
     bool screensaver_enabled;
     struct m_config_cache *opts_cache;
+    int display_orientation;
 
     // options
     int allow_sw;
@@ -402,7 +404,8 @@ static void set_fullscreen(struct vo *vo)
 {
     struct priv *vc = vo->priv;
     struct mp_vo_opts *opts = vc->opts_cache->opts;
-    int fs = opts->fullscreen;
+    //int fs = opts->fullscreen;
+    int fs = true; /* Set default fullscreen for sailfishos */
     SDL_bool prev_screensaver_state = SDL_IsScreenSaverEnabled();
 
     Uint32 fs_flag;
@@ -441,6 +444,8 @@ static void update_screeninfo(struct vo *vo, struct mp_rect *screenrc)
         return;
     }
     *screenrc = (struct mp_rect){0, 0, mode.w, mode.h};
+    vc->display_orientation = SDL_GetDisplayOrientation(SDL_GetWindowDisplayIndex(vc->window));
+    SDL_Log(vo, "Display orirntation %i\n", vc->display_orientation);
 }
 
 static int reconfig(struct vo *vo, struct mp_image_params *params)
@@ -550,6 +555,14 @@ static void wait_events(struct vo *vo, int64_t until_time_us)
         case SDL_QUIT:
             mp_input_put_key(vo->input_ctx, MP_KEY_CLOSE_WIN);
             break;
+        case SDL_DISPLAYEVENT:
+            SDL_Log(vo, "Display event\n");
+            struct priv *vc = vo->priv;
+            vc->display_orientation = SDL_GetDisplayOrientation(SDL_GetWindowDisplayIndex(vc->window));
+            SDL_Log(vo, "Display orientation %i\n", vc->display_orientation);
+            check_resize(vo);
+            vo_event(vo, VO_EVENT_RESIZE);            
+            break;
         case SDL_TEXTINPUT: {
             int sdl_mod = SDL_GetModState();
             int mpv_mod = 0;
@@ -827,6 +840,7 @@ static int preinit(struct vo *vo)
     SDL_SetHintWithPriority(SDL_HINT_RENDER_VSYNC, vc->vsync ? "1" : "0",
                             SDL_HINT_OVERRIDE);
 
+    SDL_SetHintWithPriority(SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION, "portrait", SDL_HINT_DEFAULT);
     if (SDL_InitSubSystem(SDL_INIT_VIDEO)) {
         MP_ERR(vo, "SDL_Init failed\n");
         return -1;
@@ -834,7 +848,8 @@ static int preinit(struct vo *vo)
 
     // then actually try
     vc->window = SDL_CreateWindow("MPV", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
-                                  640, 480, SDL_WINDOW_RESIZABLE | SDL_WINDOW_HIDDEN);
+                                  640, 480, SDL_WINDOW_RESIZABLE | SDL_WINDOW_HIDDEN |
+                                  SDL_WINDOW_FULLSCREEN_DESKTOP);
     if (!vc->window) {
         MP_ERR(vo, "SDL_CreateWindow failed\n");
         return -1;
@@ -896,17 +911,53 @@ static void draw_image(struct vo *vo, mp_image_t *mpi)
         talloc_free(mpi);
     }
 
-    SDL_Rect src, dst;
-    src.x = vc->src_rect.x0;
-    src.y = vc->src_rect.y0;
-    src.w = vc->src_rect.x1 - vc->src_rect.x0;
-    src.h = vc->src_rect.y1 - vc->src_rect.y0;
-    dst.x = vc->dst_rect.x0;
-    dst.y = vc->dst_rect.y0;
-    dst.w = vc->dst_rect.x1 - vc->dst_rect.x0;
-    dst.h = vc->dst_rect.y1 - vc->dst_rect.y0;
-
-    SDL_RenderCopy(vc->renderer, vc->tex, &src, &dst);
+    if (vc->display_orientation == SDL_ORIENTATION_LANDSCAPE ||
+        vc->display_orientation == SDL_ORIENTATION_LANDSCAPE_FLIPPED){
+
+        SDL_Rect dstrect;
+        /* Check vertical or horizontal video */
+        if (vc->src_rect.x1 - vc->src_rect.x0 > vc->src_rect.y1 - vc->src_rect.y0){
+            float scale = (float)vo->dheight/(float)(vc->dst_rect.x1 - vc->dst_rect.x0);
+            int H = vo->dwidth;
+            int W = vo->dheight;
+            dstrect.w = W;
+            dstrect.h = H;
+            H = dstrect.h = (int)((vc->dst_rect.y1 - vc->dst_rect.y0)*scale);
+            dstrect.x = ((vo->dwidth - W) / 2 - 1);
+            dstrect.y = (W - H) / 2;
+        }else{
+            float scale = (float)vo->dwidth/(float)(vc->dst_rect.y1 - vc->dst_rect.y0);
+            int H = vo->dwidth;
+            dstrect.h = H;
+            int W = dstrect.w = (int)((vc->dst_rect.x1 - vc->dst_rect.y0)*scale);
+            dstrect.x = ((H - W) / 2 - 1);
+            dstrect.y = (W - H) / 2  + (vo->dheight - W)/2;
+        }
+        if (vc->display_orientation == SDL_ORIENTATION_LANDSCAPE){
+            //SDL_Log("SDL_ORIENTATION_LANDSCAPE\n");
+            SDL_RenderCopyEx(vc->renderer, vc->tex, NULL,  &dstrect, 270.0, NULL, SDL_FLIP_NONE);
+        }else{
+            //SDL_Log("SDL_ORIENTATION_LANDSCAPE_FLIPPED\n");
+            SDL_RenderCopyEx(vc->renderer, vc->tex, NULL,  &dstrect, 90.0, NULL, SDL_FLIP_NONE);
+        }
+    }else{
+        SDL_Rect src, dst;
+        src.x = vc->src_rect.x0;
+        src.y = vc->src_rect.y0;
+        src.w = vc->src_rect.x1 - vc->src_rect.x0;
+        src.h = vc->src_rect.y1 - vc->src_rect.y0;
+        dst.x = vc->dst_rect.x0;
+        dst.y = vc->dst_rect.y0;
+        dst.w = vc->dst_rect.x1 - vc->dst_rect.x0;
+        dst.h = vc->dst_rect.y1 - vc->dst_rect.y0;
+        if (vc->display_orientation == SDL_ORIENTATION_PORTRAIT){
+            //SDL_Log("SDL_ORIENTATION_PORTRAIT\n");
+            SDL_RenderCopy(vc->renderer, vc->tex, &src, &dst);
+        }else{
+            //SDL_Log("SDL_ORIENTATION_PORTRAIT_FLIPPED\n");
+            SDL_RenderCopyEx(vc->renderer, vc->tex, &src, &dst, 180.0, NULL, SDL_FLIP_NONE);
+        }
+    }
 
     draw_osd(vo);
 }
