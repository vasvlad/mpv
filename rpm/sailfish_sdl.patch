diff --git a/meson.build b/meson.build
index fdfc526525..8d9a9cdee5 100644
--- a/meson.build
+++ b/meson.build
@@ -766,6 +766,19 @@ if features['zlib']
     dependencies += zlib
 endif
 
+keepaliveglib = dependency('keepalive-glib', required: get_option('keepaliveglib'))
+features += {'keepaliveglib': keepaliveglib.found()}
+if features['keepaliveglib']
+    dependencies += keepaliveglib
+#    dependencies += cc.find_library('keepdisplayon')
+    dependencies += cc.find_library('keepdisplayonplugin')
+endif
+
+dbus = dependency('dbus-1', required: get_option('dbus'))
+features += {'dbus': dbus.found()}
+if features['dbus']
+    dependencies += dbus
+endif
 
 # audio output dependencies
 alsa = dependency('alsa', version: '>= 1.0.18', required: get_option('alsa'))
@@ -973,9 +986,6 @@ wayland = {
              dependency('wayland-cursor', version: '>= 1.20.0', required: get_option('wayland')),
              dependency('wayland-protocols', version: '>= 1.25', required: get_option('wayland')),
              dependency('xkbcommon', version: '>= 0.3.0', required: get_option('wayland'))],
-    'header': cc.has_header('linux/input-event-codes.h', required: get_option('wayland'),
-                            # Pass CFLAGS from a related package as a hint for non-Linux
-                            dependencies: dependency('wayland-client', required: get_option('wayland'))),
     'scanner': find_program('wayland-scanner', required: get_option('wayland')),
 }
 wayland_deps = true
@@ -985,7 +995,7 @@ foreach dep: wayland['deps']
         break
     endif
 endforeach
-features += {'wayland': wayland_deps and wayland['header'] and wayland['scanner'].found()}
+features += {'wayland': wayland_deps and wayland['scanner'].found()}
 
 if features['wayland']
     subdir(join_paths('video', 'out'))
@@ -1049,7 +1059,7 @@ if features['xv']
     sources += files('video/out/vo_xv.c')
 endif
 
-if features['wayland'] or features['x11']
+if features['wayland'] or features['x11'] or features['drm']
     sources += ('video/out/present_sync.c')
 endif
 
diff --git a/meson_options.txt b/meson_options.txt
index b0edb8018f..ae7f0879aa 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -37,6 +37,8 @@ option('vector', type: 'feature', value: 'auto', description: 'GCC vector instru
 option('win32-threads', type: 'feature', value: 'auto', description: 'win32 threads')
 option('zimg', type: 'feature', value: 'auto', description: 'libzimg support (high quality software scaler)')
 option('zlib', type: 'feature', value: 'auto', description: 'zlib')
+option('keepaliveglib', type: 'feature', value: 'auto', description: 'libkeepalive-glib-devel')
+option('dbus', type: 'feature', value: 'auto', description: 'dbus')
 
 # audio output features
 option('alsa', type: 'feature', value: 'auto', description: 'ALSA audio output')
diff --git a/player/command.c b/player/command.c
index 8bff0cd6f9..a8845a0252 100644
--- a/player/command.c
+++ b/player/command.c
@@ -2752,12 +2752,26 @@ static int mp_property_osd_dim(void *ctx, struct m_property *prop,
     if (!mpctx->video_out || !mpctx->video_out->config_ok)
         vo_res = (struct mp_osd_res){0};
 
-    double aspect = 1.0 * vo_res.w / MPMAX(vo_res.h, 1) /
+//    double aspect = 1.0 * vo_res.w / MPMAX(vo_res.h, 1) /
+    /* Hack for Sailfishos and AuroraOS mobile devices */
+    int w, h;
+    if (vo_res.w < vo_res.h){
+        w = vo_res.w;
+        h = vo_res.h;
+    }else{
+        h = vo_res.w;
+        w = vo_res.h;
+    }
+
+    double aspect = 1.0 * w / MPMAX(h, 1) /
                     (vo_res.display_par ? vo_res.display_par : 1);
 
     struct m_sub_property props[] = {
-        {"w",       SUB_PROP_INT(vo_res.w)},
-        {"h",       SUB_PROP_INT(vo_res.h)},
+        {"w",       SUB_PROP_INT(w)},
+        {"h",       SUB_PROP_INT(h)},
+//        {"w",       SUB_PROP_INT(vo_res.w)},
+//        {"h",       SUB_PROP_INT(vo_res.h)},
+
         {"par",     SUB_PROP_DOUBLE(vo_res.display_par)},
         {"aspect",  SUB_PROP_DOUBLE(aspect)},
         {"mt",      SUB_PROP_INT(vo_res.mt)},
diff --git a/player/lua/osc.lua b/player/lua/osc.lua
index 45a5d90f78..f503545ee1 100644
--- a/player/lua/osc.lua
+++ b/player/lua/osc.lua
@@ -21,7 +21,7 @@ local user_opts = {
     barmargin = 0,              -- vertical margin of top/bottombar
     boxalpha = 80,              -- alpha of the background box,
                                 -- 0 (opaque) to 255 (fully transparent)
-    hidetimeout = 500,          -- duration in ms until the OSC hides if no
+    hidetimeout = 4000,          -- duration in ms until the OSC hides if no
                                 -- mouse movement. enforced non-negative for the
                                 -- user, but internally negative is "always-on".
     fadeduration = 200,         -- duration of fade out in ms, 0 = no fade
@@ -2602,38 +2602,20 @@ function tick()
 
         -- render idle message
         msg.trace("idle message")
-        local _, _, display_aspect = mp.get_osd_size()
+        local display_w, display_h, display_aspect = mp.get_osd_size()
         if display_aspect == 0 then
             return
         end
-        local display_h = 360
-        local display_w = display_h * display_aspect
         -- logo is rendered at 2^(6-1) = 32 times resolution with size 1800x1800
-        local icon_x, icon_y = (display_w - 1800 / 32) / 2, 140
+        local icon_x, icon_y = 0,0
         local line_prefix = ("{\\rDefault\\an7\\1a&H00&\\bord0\\shad0\\pos(%f,%f)}"):format(icon_x, icon_y)
 
         local ass = assdraw.ass_new()
-        -- mpv logo
-        if user_opts.idlescreen then
-            for i, line in ipairs(logo_lines) do
-                ass:new_event()
-                ass:append(line_prefix .. line)
-            end
-        end
-
-        -- Santa hat
-        if is_december and user_opts.idlescreen and not user_opts.greenandgrumpy then
-            for i, line in ipairs(santa_hat_lines) do
-                ass:new_event()
-                ass:append(line_prefix .. line)
-            end
-        end
-
         if user_opts.idlescreen then
             ass:new_event()
-            ass:pos(display_w / 2, icon_y + 65)
-            ass:an(8)
-            ass:append("Drop files or URLs to play here.")
+            ass:pos(0, 0)
+            ass:an(7)
+            ass:append("{\\fscy50\\fscx50}Use the command in terminal: \\N {\\fscy25\\fscx25} harbour-mpvsdl [url|path/]filename \\N{\\fscy50\\fscx50} to play the video.")
         end
         set_osd(display_w, display_h, ass.text, -1000)
 
diff --git a/player/main.c b/player/main.c
index 27cf9b4449..2a937bcf0a 100644
--- a/player/main.c
+++ b/player/main.c
@@ -351,6 +351,7 @@ int mp_initialize(struct MPContext *mpctx, char **options)
             return r == M_OPT_EXIT ? 1 : -1;
     }
 
+    // set --player-operation-mode=pseudo-gui by default Hack For SailfisOS and AuroraOS mobiledevice
     if (opts->operation_mode == 1) {
         m_config_set_profile(mpctx->mconfig, "builtin-pseudo-gui",
                              M_SETOPT_NO_OVERWRITE);
diff --git a/player/scripting.c b/player/scripting.c
index 0b200815f1..769f6e248c 100644
--- a/player/scripting.c
+++ b/player/scripting.c
@@ -42,8 +42,10 @@
 #include "libmpv/render.h"
 #include "libmpv/stream_cb.h"
 
+extern int mpv_open_keepdisplay(mpv_handle *mpv);
 extern const struct mp_scripting mp_scripting_lua;
 extern const struct mp_scripting mp_scripting_cplugin;
+extern const struct mp_scripting mp_scripting_cplugin_static;
 extern const struct mp_scripting mp_scripting_js;
 extern const struct mp_scripting mp_scripting_run;
 
@@ -53,6 +55,7 @@ static const struct mp_scripting *const scripting_backends[] = {
 #endif
 #if HAVE_CPLUGINS
     &mp_scripting_cplugin,
+    &mp_scripting_cplugin_static,
 #endif
 #if HAVE_JAVASCRIPT
     &mp_scripting_js,
@@ -257,6 +260,50 @@ static void load_builtin_script(struct MPContext *mpctx, int slot, bool enable,
     }
 }
 
+void load_static_plugin_keepdisplay(struct MPContext *mpctx){
+    const struct mp_scripting *backend = NULL;
+    char *script_name = NULL;
+    void *tmp = talloc_new(NULL);
+    for (int n = 0; scripting_backends[n]; n++) {
+        const struct mp_scripting *b = scripting_backends[n];
+        if (strcasecmp("a", b->file_ext) == 0) {
+            backend = b;
+            fprintf(stderr,"find backend load_static_plugin_keepdisplay\n");
+            break;
+        }
+    }
+    struct mp_script_args *arg = talloc_ptrtype(NULL, arg);
+    *arg = (struct mp_script_args){
+        .mpctx = mpctx,
+        .backend = backend,
+        // Create the client before creating the thread; otherwise a race
+        // condition could happen, where MPContext is destroyed while the
+        // thread tries to create the client.
+        .client = mp_new_client(mpctx->clients, script_name),
+    };
+    if (!arg->client) {
+        MP_ERR(mpctx, "Failed to create client for script: %s\n", script_name);
+        talloc_free(arg);
+        return -1;
+    }
+    mp_client_set_weak(arg->client);
+    arg->log = mp_client_get_log(arg->client);
+    int64_t id = mpv_client_id(arg->client);
+
+    MP_DBG(arg, "Loading %s script %s...\n", backend->name, arg->filename);
+    mp_thread thread;
+    if (mp_thread_create(&thread, script_thread, arg)) {
+        mpv_destroy(arg->client);
+        talloc_free(arg);
+        MP_ERR(mpctx, "Failed to create thread for script: %s\n", script_name);
+        talloc_free(tmp);
+        return;
+    }
+    mp_thread_detach(thread);
+
+    talloc_free(tmp);
+
+}
 void mp_load_builtin_scripts(struct MPContext *mpctx)
 {
     load_builtin_script(mpctx, 0, mpctx->opts->lua_load_osc, "@osc.lua");
@@ -265,6 +312,7 @@ void mp_load_builtin_scripts(struct MPContext *mpctx)
     load_builtin_script(mpctx, 3, mpctx->opts->lua_load_console, "@console.lua");
     load_builtin_script(mpctx, 4, mpctx->opts->lua_load_auto_profiles,
                         "@auto_profiles.lua");
+    load_static_plugin_keepdisplay(mpctx);
 }
 
 bool mp_load_scripts(struct MPContext *mpctx)
@@ -372,6 +420,17 @@ static void init_sym_table(struct mp_script_args *args, void *lib) {
 #undef INIT_SYM
 }
 
+static int load_cplugin_static(struct mp_script_args *args)
+{
+    mpv_open_cplugin sym = (mpv_open_cplugin)mpv_open_keepdisplay;
+    if (!sym)
+        goto error;
+    return sym(args->client) ? -1 : 0;
+error: ;
+    MP_ERR(args, "C static plugin error: '%s'\n");
+    return -1;
+}
+
 static int load_cplugin(struct mp_script_args *args)
 {
     void *lib = dlopen(args->filename, RTLD_NOW | RTLD_LOCAL);
@@ -403,6 +462,12 @@ const struct mp_scripting mp_scripting_cplugin = {
     .load = load_cplugin,
 };
 
+const struct mp_scripting mp_scripting_cplugin_static = {
+    .name = "cpluginstatic",
+    .file_ext = "a",
+    .load = load_cplugin_static,
+};
+
 #endif
 
 static int load_run(struct mp_script_args *args)
diff --git a/video/out/vo_sdl.c b/video/out/vo_sdl.c
index 5f4c027ed5..a542fb60d3 100644
--- a/video/out/vo_sdl.c
+++ b/video/out/vo_sdl.c
@@ -29,6 +29,7 @@
 #include <assert.h>
 
 #include <SDL.h>
+#include <SDL_video.h>
 
 #include "input/input.h"
 #include "input/keycodes.h"
@@ -190,6 +191,8 @@ struct priv {
     Uint32 wakeup_event;
     bool screensaver_enabled;
     struct m_config_cache *opts_cache;
+    int display_orientation;
+    float screenCoef;
 
     // options
     bool allow_sw;
@@ -197,6 +200,7 @@ struct priv {
     bool vsync;
 };
 
+
 static bool lock_texture(struct vo *vo, struct mp_image *texmpi)
 {
     struct priv *vc = vo->priv;
@@ -364,6 +368,16 @@ static void resize(struct vo *vo, int w, int h)
     vo->dheight = h;
     vo_get_src_dst_rects(vo, &vc->src_rect, &vc->dst_rect,
                          &vc->osd_res);
+#if 0
+    /* Change size for OSD */
+    if (vc->display_orientation == SDL_ORIENTATION_LANDSCAPE ||
+        vc->display_orientation == SDL_ORIENTATION_LANDSCAPE_FLIPPED){
+        int temp = vc->osd_res.h;
+        vc->osd_res.h = vc->osd_res.w;
+        vc->osd_res.w = temp;
+    }
+#endif
+    vc->screenCoef = (float)vo->dheight/(float)(vo->dwidth);
     SDL_RenderSetLogicalSize(vc->renderer, w, h);
     vo->want_redraw = true;
     vo_wakeup(vo);
@@ -401,7 +415,8 @@ static void set_fullscreen(struct vo *vo)
 {
     struct priv *vc = vo->priv;
     struct mp_vo_opts *opts = vc->opts_cache->opts;
-    int fs = opts->fullscreen;
+    //int fs = opts->fullscreen;
+    int fs = true; /* Set default fullscreen for sailfishos */
     SDL_bool prev_screensaver_state = SDL_IsScreenSaverEnabled();
 
     Uint32 fs_flag;
@@ -440,6 +455,8 @@ static void update_screeninfo(struct vo *vo, struct mp_rect *screenrc)
         return;
     }
     *screenrc = (struct mp_rect){0, 0, mode.w, mode.h};
+    vc->display_orientation = SDL_GetDisplayOrientation(SDL_GetWindowDisplayIndex(vc->window));
+    //SDL_Log("Display orientation %i\n", vc->display_orientation);
 }
 
 static int reconfig(struct vo *vo, struct mp_image_params *params)
@@ -520,8 +537,34 @@ static void wakeup(struct vo *vo)
     SDL_PushEvent(&event);
 }
 
+static void convertMousePostition(struct vo *vo, int *x, int *y) 
+{
+    struct priv *vc = vo->priv;
+    int w, h;
+    SDL_GetWindowSize(vc->window, &w, &h);
+
+    if (vc->display_orientation == SDL_ORIENTATION_PORTRAIT){
+        return;
+    }else if (vc->display_orientation == SDL_ORIENTATION_PORTRAIT_FLIPPED) {
+        *x = (w - *x);
+        *y = (h - *y);
+        return;
+    }
+    int tmp = *x;
+    if (vc->display_orientation == SDL_ORIENTATION_LANDSCAPE_FLIPPED) {
+        *x = (int)(float)*y/(float)vc->screenCoef;
+        *y = (h - tmp);
+        return;
+    } else if (vc->display_orientation == SDL_ORIENTATION_LANDSCAPE) {
+        *x = (int)((float)(h - *y)/(float)vc->screenCoef);
+        *y = (int)((float)(tmp)*(float)vc->screenCoef);
+        return;
+    }
+}
+
 static void wait_events(struct vo *vo, int64_t until_time_ns)
 {
+    struct priv *vc = vo->priv;
     int64_t wait_ns = until_time_ns - mp_time_ns();
     // Round-up to 1ms for short timeouts (100us, 1000us]
     if (wait_ns > MP_TIME_US_TO_NS(100))
@@ -552,6 +595,37 @@ static void wait_events(struct vo *vo, int64_t until_time_ns)
         case SDL_QUIT:
             mp_input_put_key(vo->input_ctx, MP_KEY_CLOSE_WIN);
             break;
+        case SDL_DISPLAYEVENT:
+            vc->display_orientation = SDL_GetDisplayOrientation(SDL_GetWindowDisplayIndex(vc->window));
+            switch (vc->display_orientation) {
+                case SDL_ORIENTATION_LANDSCAPE:
+                    SDL_Log("Display event SDL_ORIENTATION_LANDSCAPE\n");
+                    SDL_SetHint(SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION,"landscape");
+                    break;
+                case SDL_ORIENTATION_LANDSCAPE_FLIPPED:
+                    SDL_Log("Display event SDL_ORIENTATION_LANDSCAPE_FLIPPED\n");
+                    SDL_SetHint(SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION,"inverted-landscape");
+                    break;
+                case SDL_ORIENTATION_PORTRAIT:
+                    SDL_Log("Display event SDL_ORIENTATION_PORTRAIT\n");
+                    SDL_SetHint(SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION,"portrait");
+                    break;
+                case SDL_ORIENTATION_PORTRAIT_FLIPPED:
+                    SDL_Log("Display event SDL_ORIENTATION_PORTRAIT_FLIPPED\n");
+                    SDL_SetHint(SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION,"inverted-portrait");
+                    break;
+                default:
+                case SDL_ORIENTATION_UNKNOWN:
+                    SDL_Log("Display event SDL_ORIENTATION_UNKNOWN\n");
+                    SDL_SetHint(SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION,"landscape");
+                    // printf("SDL_DisplayOrientation is SDL_ORIENTATION_UNKNOWN\n");
+                    break;
+            }
+
+            //SDL_Log(vo, "Display orientation %i\n", vc->display_orientation);
+            check_resize(vo);
+            vo_event(vo, VO_EVENT_RESIZE);            
+            break;
         case SDL_TEXTINPUT: {
             int sdl_mod = SDL_GetModState();
             int mpv_mod = 0;
@@ -601,6 +675,7 @@ static void wait_events(struct vo *vo, int64_t until_time_ns)
             break;
         }
         case SDL_MOUSEMOTION:
+            convertMousePostition(vo, &ev.motion.x, &ev.motion.y);
             mp_input_set_mouse_pos(vo->input_ctx, ev.motion.x, ev.motion.y);
             break;
         case SDL_MOUSEBUTTONDOWN: {
@@ -779,6 +854,70 @@ static void draw_osd_part(struct vo *vo, int index)
     struct osd_bitmap_surface *sfc = &vc->osd_surfaces[index];
     int i;
 
+    for (i = 0; i < sfc->num_targets; i++) {
+        struct osd_target *target = sfc->targets + i;
+        SDL_Rect dstrect;
+        int H = (int)(target->dest.h*vc->screenCoef);
+        int W = (int)(target->dest.w*vc->screenCoef);
+        dstrect.w = W;
+        dstrect.h = H;
+        dstrect.x = ((H - W) / 2 - 1);
+        dstrect.y = (W - H) / 2  + (vo->dheight - W)/2;
+
+        if (vc->display_orientation == SDL_ORIENTATION_LANDSCAPE ||
+            vc->display_orientation == SDL_ORIENTATION_LANDSCAPE_FLIPPED){
+            if (vc->display_orientation == SDL_ORIENTATION_LANDSCAPE){
+                dstrect.x = (H - W) / 2 + vo->dwidth - dstrect.h; 
+                if (target->tex){
+                    SDL_RenderCopyEx(vc->renderer, target->tex, NULL, &dstrect, 270.0, NULL, SDL_FLIP_NONE);
+                }
+                if (target->tex2){
+                    SDL_RenderCopyEx(vc->renderer, target->tex2, NULL, &dstrect, 270.0, NULL, SDL_FLIP_NONE);
+                }
+            }else{
+                if (target->tex){
+                    SDL_RenderCopyEx(vc->renderer, target->tex, NULL, &dstrect, 90.0, NULL, SDL_FLIP_NONE);
+                }
+                if (target->tex2){
+                    SDL_RenderCopyEx(vc->renderer, target->tex2, NULL, &dstrect, 90.0, NULL, SDL_FLIP_NONE);
+                }
+            }
+        }else{
+            if (vc->display_orientation == SDL_ORIENTATION_PORTRAIT){
+                target->dest.y = vo->dheight - target->dest.h;
+                //target->dest.w = vo->dwidth;
+                if (target->tex){
+                    SDL_RenderCopy(vc->renderer, target->tex,
+                                   &target->source, &target->dest);
+                }
+                if (target->tex2){
+                    SDL_RenderCopy(vc->renderer, target->tex2,
+                                   &target->source, &target->dest);
+                }
+            }else{
+                //target->dest.w = vo->dwidth;
+                target->dest.y = 0;
+                if (target->tex){
+                    SDL_RenderCopyEx(vc->renderer, target->tex,
+                                   &target->source, &target->dest, 180.0, NULL, SDL_FLIP_NONE);
+                }
+                if (target->tex2){
+                    SDL_RenderCopyEx(vc->renderer, target->tex2,
+                                   &target->source, &target->dest, 180.0, NULL, SDL_FLIP_NONE);
+                }
+            }
+        }
+    }
+}
+
+/*
+static void draw_osd_part(struct vo *vo, int index)
+{
+    struct priv *vc = vo->priv;
+    struct osd_bitmap_surface *sfc = &vc->osd_surfaces[index];
+    int i;
+
+//    fprintf(stderr,"draw_osd_part\n");
     for (i = 0; i < sfc->num_targets; i++) {
         struct osd_target *target = sfc->targets + i;
         if (target->tex)
@@ -790,6 +929,7 @@ static void draw_osd_part(struct vo *vo, int index)
     }
 }
 
+*/
 static void draw_osd_cb(void *ctx, struct sub_bitmaps *imgs)
 {
     struct vo *vo = ctx;
@@ -829,6 +969,7 @@ static int preinit(struct vo *vo)
     SDL_SetHintWithPriority(SDL_HINT_RENDER_VSYNC, vc->vsync ? "1" : "0",
                             SDL_HINT_OVERRIDE);
 
+    SDL_SetHintWithPriority(SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION, "portrait", SDL_HINT_DEFAULT);
     if (SDL_InitSubSystem(SDL_INIT_VIDEO)) {
         MP_ERR(vo, "SDL_Init failed\n");
         return -1;
@@ -836,7 +977,8 @@ static int preinit(struct vo *vo)
 
     // then actually try
     vc->window = SDL_CreateWindow("MPV", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
-                                  640, 480, SDL_WINDOW_RESIZABLE | SDL_WINDOW_HIDDEN);
+                                  640, 480, SDL_WINDOW_RESIZABLE | SDL_WINDOW_HIDDEN |
+                                  SDL_WINDOW_FULLSCREEN_DESKTOP);
     if (!vc->window) {
         MP_ERR(vo, "SDL_CreateWindow failed\n");
         return -1;
@@ -894,17 +1036,52 @@ static void draw_frame(struct vo *vo, struct vo_frame *frame)
         SDL_UnlockTexture(vc->tex);
     }
 
-    SDL_Rect src, dst;
-    src.x = vc->src_rect.x0;
-    src.y = vc->src_rect.y0;
-    src.w = vc->src_rect.x1 - vc->src_rect.x0;
-    src.h = vc->src_rect.y1 - vc->src_rect.y0;
-    dst.x = vc->dst_rect.x0;
-    dst.y = vc->dst_rect.y0;
-    dst.w = vc->dst_rect.x1 - vc->dst_rect.x0;
-    dst.h = vc->dst_rect.y1 - vc->dst_rect.y0;
+    if (vc->display_orientation == SDL_ORIENTATION_LANDSCAPE ||
+        vc->display_orientation == SDL_ORIENTATION_LANDSCAPE_FLIPPED){
+
+        SDL_Rect dstrect;
+        /* Check vertical or horizontal video */
+        if (vc->src_rect.x1 - vc->src_rect.x0 > vc->src_rect.y1 - vc->src_rect.y0){
+            float scale = (float)vo->dheight/(float)(vc->dst_rect.x1 - vc->dst_rect.x0);
+            int H = vo->dwidth;
+            int W = vo->dheight;
+            dstrect.w = W;
+            dstrect.h = H;
+            H = dstrect.h = (int)((vc->dst_rect.y1 - vc->dst_rect.y0)*scale);
+            dstrect.x = ((vo->dwidth - W) / 2 - 1);
+            dstrect.y = (W - H) / 2;
+        }else{
+            float scale = (float)vo->dwidth/(float)(vc->dst_rect.y1 - vc->dst_rect.y0);
+            int H = vo->dwidth;
+            dstrect.h = H;
+            int W = dstrect.w = (int)((vc->dst_rect.x1 - vc->dst_rect.y0)*scale);
+            dstrect.x = ((H - W) / 2 - 1);
+            dstrect.y = (W - H) / 2  + (vo->dheight - W)/2;
+        }
 
-    SDL_RenderCopy(vc->renderer, vc->tex, &src, &dst);
+        if (vc->display_orientation == SDL_ORIENTATION_LANDSCAPE){
+            SDL_RenderCopyEx(vc->renderer, vc->tex, NULL,  &dstrect, 270.0, NULL, SDL_FLIP_NONE);
+        }else{
+            SDL_RenderCopyEx(vc->renderer, vc->tex, NULL,  &dstrect, 90.0, NULL, SDL_FLIP_NONE);
+        }
+    }else{
+        SDL_Rect src, dst;
+        src.x = vc->src_rect.x0;
+        src.y = vc->src_rect.y0;
+        src.w = vc->src_rect.x1 - vc->src_rect.x0;
+        src.h = vc->src_rect.y1 - vc->src_rect.y0;
+        dst.x = vc->dst_rect.x0;
+        dst.y = vc->dst_rect.y0;
+        dst.w = vc->dst_rect.x1 - vc->dst_rect.x0;
+        dst.h = vc->dst_rect.y1 - vc->dst_rect.y0;
+        if (vc->display_orientation == SDL_ORIENTATION_PORTRAIT){
+            //SDL_Log("SDL_ORIENTATION_PORTRAIT\n");
+            SDL_RenderCopy(vc->renderer, vc->tex, &src, &dst);
+        }else{
+            //SDL_Log("SDL_ORIENTATION_PORTRAIT_FLIPPED\n");
+            SDL_RenderCopyEx(vc->renderer, vc->tex, &src, &dst, 180.0, NULL, SDL_FLIP_NONE);
+        }
+    }
 
     draw_osd(vo);
 }
