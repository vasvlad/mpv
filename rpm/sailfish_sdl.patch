diff --git a/player/lua/osc.lua b/player/lua/osc.lua
index a244280a35..af9fff0791 100644
--- a/player/lua/osc.lua
+++ b/player/lua/osc.lua
@@ -21,7 +21,7 @@ local user_opts = {
     barmargin = 0,              -- vertical margin of top/bottombar
     boxalpha = 80,              -- alpha of the background box,
                                 -- 0 (opaque) to 255 (fully transparent)
-    hidetimeout = 500,          -- duration in ms until the OSC hides if no
+    hidetimeout = 5000,          -- duration in ms until the OSC hides if no
                                 -- mouse movement. enforced non-negative for the
                                 -- user, but internally negative is "always-on".
     fadeduration = 200,         -- duration of fade out in ms, 0 = no fade
@@ -2595,7 +2595,8 @@ function tick()
         local display_h = 360
         local display_w = display_h * display_aspect
         -- logo is rendered at 2^(6-1) = 32 times resolution with size 1800x1800
-        local icon_x, icon_y = (display_w - 1800 / 32) / 2, 140
+        -- local icon_x, icon_y = (display_w - 1800 / 32) / 2, 140
+        local icon_x, icon_y = (display_w - 1800 / 32) / 2, 40
         local line_prefix = ("{\\rDefault\\an7\\1a&H00&\\bord0\\shad0\\pos(%f,%f)}"):format(icon_x, icon_y)
 
         local ass = assdraw.ass_new()
@@ -2619,7 +2620,7 @@ function tick()
             ass:new_event()
             ass:pos(display_w / 2, icon_y + 65)
             ass:an(8)
-            ass:append("Drop files or URLs to play here.")
+            ass:append("Use the command in terminal: {\\fscy50\\fscx50} org.meecast.mpv [url|path/]filename {\\fscy100\\fscx100} to play the video.")
         end
         set_osd(display_w, display_h, ass.text)
 
diff --git a/player/main.c b/player/main.c
index 1c1cdf9f29..2e83872925 100644
--- a/player/main.c
+++ b/player/main.c
@@ -347,11 +347,12 @@ int mp_initialize(struct MPContext *mpctx, char **options)
             return r == M_OPT_EXIT ? 1 : -1;
     }
 
-    if (opts->operation_mode == 1) {
+    // set --player-operation-mode=pseudo-gui by default
+    //if (opts->operation_mode == 1) {
         m_config_set_profile(mpctx->mconfig, "builtin-pseudo-gui",
                              M_SETOPT_NO_OVERWRITE);
         m_config_set_profile(mpctx->mconfig, "pseudo-gui", 0);
-    }
+    //}
 
     // Backup the default settings, which should not be stored in the resume
     // config files. This explicitly includes values set by config files and
diff --git a/video/out/vo_sdl.c b/video/out/vo_sdl.c
index adfcfb43d8..4fd76a4a7a 100644
--- a/video/out/vo_sdl.c
+++ b/video/out/vo_sdl.c
@@ -29,6 +29,7 @@
 #include <assert.h>
 
 #include <SDL.h>
+#include <SDL_video.h>
 
 #include "input/input.h"
 #include "input/keycodes.h"
@@ -191,6 +192,7 @@ struct priv {
     Uint32 wakeup_event;
     bool screensaver_enabled;
     struct m_config_cache *opts_cache;
+    int display_orientation;
 
     // options
     int allow_sw;
@@ -365,6 +367,14 @@ static void resize(struct vo *vo, int w, int h)
     vo->dheight = h;
     vo_get_src_dst_rects(vo, &vc->src_rect, &vc->dst_rect,
                          &vc->osd_res);
+    /* Chnage size for OSD */
+    if (vc->display_orientation == SDL_ORIENTATION_LANDSCAPE ||
+        vc->display_orientation == SDL_ORIENTATION_LANDSCAPE_FLIPPED){
+        int temp = vc->osd_res.h;
+        vc->osd_res.h = vc->osd_res.w;
+        vc->osd_res.w = temp;
+    }
+
     SDL_RenderSetLogicalSize(vc->renderer, w, h);
     vo->want_redraw = true;
     vo_wakeup(vo);
@@ -402,7 +412,8 @@ static void set_fullscreen(struct vo *vo)
 {
     struct priv *vc = vo->priv;
     struct mp_vo_opts *opts = vc->opts_cache->opts;
-    int fs = opts->fullscreen;
+    //int fs = opts->fullscreen;
+    int fs = true; /* Set default fullscreen for sailfishos */
     SDL_bool prev_screensaver_state = SDL_IsScreenSaverEnabled();
 
     Uint32 fs_flag;
@@ -441,6 +452,8 @@ static void update_screeninfo(struct vo *vo, struct mp_rect *screenrc)
         return;
     }
     *screenrc = (struct mp_rect){0, 0, mode.w, mode.h};
+    vc->display_orientation = SDL_GetDisplayOrientation(SDL_GetWindowDisplayIndex(vc->window));
+    //SDL_Log(vo, "Display orirntation %i\n", vc->display_orientation);
 }
 
 static int reconfig(struct vo *vo, struct mp_image_params *params)
@@ -550,6 +563,14 @@ static void wait_events(struct vo *vo, int64_t until_time_us)
         case SDL_QUIT:
             mp_input_put_key(vo->input_ctx, MP_KEY_CLOSE_WIN);
             break;
+        case SDL_DISPLAYEVENT:
+            //SDL_Log(vo, "Display event\n");
+            struct priv *vc = vo->priv;
+            vc->display_orientation = SDL_GetDisplayOrientation(SDL_GetWindowDisplayIndex(vc->window));
+            //SDL_Log(vo, "Display orientation %i\n", vc->display_orientation);
+            check_resize(vo);
+            vo_event(vo, VO_EVENT_RESIZE);            
+            break;
         case SDL_TEXTINPUT: {
             int sdl_mod = SDL_GetModState();
             int mpv_mod = 0;
@@ -777,14 +798,61 @@ static void draw_osd_part(struct vo *vo, int index)
     struct osd_bitmap_surface *sfc = &vc->osd_surfaces[index];
     int i;
 
+            
+
     for (i = 0; i < sfc->num_targets; i++) {
         struct osd_target *target = sfc->targets + i;
-        if (target->tex)
-            SDL_RenderCopy(vc->renderer, target->tex,
-                           &target->source, &target->dest);
-        if (target->tex2)
-            SDL_RenderCopy(vc->renderer, target->tex2,
-                           &target->source, &target->dest);
+            SDL_Rect dstrect;
+            float scale = (float)vo->dheight/(float)(target->dest.w);
+            int H = (int)(target->dest.h*scale);
+            int W = vo->dheight;
+
+            dstrect.w = W;
+            dstrect.h = H;
+            dstrect.x = ((H - W) / 2 - 1);
+            dstrect.y = (W - H) / 2  + (vo->dheight - W)/2;
+
+        if (vc->display_orientation == SDL_ORIENTATION_LANDSCAPE ||
+            vc->display_orientation == SDL_ORIENTATION_LANDSCAPE_FLIPPED){
+
+            if (vc->display_orientation == SDL_ORIENTATION_LANDSCAPE){
+                dstrect.x = -target->dest.h;
+                SDL_Log("SDL_ORIENTATION_LANDSCAPE dstrect.w %d, dstrect.h %d, dstrect.x %d, dstrect.y %d\n", dstrect.w, dstrect.h, dstrect.x, dstrect.y);
+                if (target->tex)
+                    SDL_RenderCopyEx(vc->renderer, target->tex, NULL, &dstrect, 270.0, NULL, SDL_FLIP_NONE);
+                if (target->tex2)
+                    SDL_RenderCopyEx(vc->renderer, target->tex2, NULL, &dstrect, 270.0, NULL, SDL_FLIP_NONE);
+            }else{
+                SDL_Log("SDL_ORIENTATION_LANDSCAPE_FLIPPED dstrect.w %d, dstrect.h %d, dstrect.x %d, dstrect.y %d\n", dstrect.w, dstrect.h, dstrect.x, dstrect.y);
+                if (target->tex)
+                    SDL_RenderCopyEx(vc->renderer, target->tex, NULL, &dstrect, 90.0, NULL, SDL_FLIP_NONE);
+                if (target->tex2)
+                    SDL_RenderCopyEx(vc->renderer, target->tex2, NULL, &dstrect, 90.0, NULL, SDL_FLIP_NONE);
+            }
+        }else{
+            if (vc->display_orientation == SDL_ORIENTATION_PORTRAIT){
+                SDL_Log("SDL_ORIENTATION_PORTRAIT dstrect.w %d, dstrect.h %d, dstrect.x %d, dstrect.y %d\n", dstrect.w, dstrect.h, dstrect.x, dstrect.y);
+                if (target->tex){
+                    SDL_RenderCopy(vc->renderer, target->tex,
+                                   &target->source, &target->dest);
+                }
+                if (target->tex2){
+                    SDL_RenderCopy(vc->renderer, target->tex2,
+                                   &target->source, &target->dest);
+                }
+            }else{
+                target->dest.y = dstrect.h-target->dest.h;
+                SDL_Log("SDL_ORIENTATION_PORTRAIT_FLIPPED dstrect.w %d, dstrect.h %d, dstrect.x %d, dstrect.y %d target->dest.y %d\n", dstrect.w, dstrect.h, dstrect.x, dstrect.y, target->dest.y);
+                if (target->tex){
+                    SDL_RenderCopyEx(vc->renderer, target->tex,
+                                   &target->source, &target->dest, 180.0, NULL, SDL_FLIP_NONE);
+                }
+                if (target->tex2){
+                    SDL_RenderCopyEx(vc->renderer, target->tex2,
+                                   &target->source, &target->dest, 180.0, NULL, SDL_FLIP_NONE);
+                }
+            }
+        }
     }
 }
 
@@ -827,6 +895,7 @@ static int preinit(struct vo *vo)
     SDL_SetHintWithPriority(SDL_HINT_RENDER_VSYNC, vc->vsync ? "1" : "0",
                             SDL_HINT_OVERRIDE);
 
+    SDL_SetHintWithPriority(SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION, "portrait", SDL_HINT_DEFAULT);
     if (SDL_InitSubSystem(SDL_INIT_VIDEO)) {
         MP_ERR(vo, "SDL_Init failed\n");
         return -1;
@@ -834,7 +903,8 @@ static int preinit(struct vo *vo)
 
     // then actually try
     vc->window = SDL_CreateWindow("MPV", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
-                                  640, 480, SDL_WINDOW_RESIZABLE | SDL_WINDOW_HIDDEN);
+                                  640, 480, SDL_WINDOW_RESIZABLE | SDL_WINDOW_HIDDEN |
+                                  SDL_WINDOW_FULLSCREEN_DESKTOP);
     if (!vc->window) {
         MP_ERR(vo, "SDL_CreateWindow failed\n");
         return -1;
@@ -896,17 +966,53 @@ static void draw_image(struct vo *vo, mp_image_t *mpi)
         talloc_free(mpi);
     }
 
-    SDL_Rect src, dst;
-    src.x = vc->src_rect.x0;
-    src.y = vc->src_rect.y0;
-    src.w = vc->src_rect.x1 - vc->src_rect.x0;
-    src.h = vc->src_rect.y1 - vc->src_rect.y0;
-    dst.x = vc->dst_rect.x0;
-    dst.y = vc->dst_rect.y0;
-    dst.w = vc->dst_rect.x1 - vc->dst_rect.x0;
-    dst.h = vc->dst_rect.y1 - vc->dst_rect.y0;
-
-    SDL_RenderCopy(vc->renderer, vc->tex, &src, &dst);
+    if (vc->display_orientation == SDL_ORIENTATION_LANDSCAPE ||
+        vc->display_orientation == SDL_ORIENTATION_LANDSCAPE_FLIPPED){
+
+        SDL_Rect dstrect;
+        /* Check vertical or horizontal video */
+        if (vc->src_rect.x1 - vc->src_rect.x0 > vc->src_rect.y1 - vc->src_rect.y0){
+            float scale = (float)vo->dheight/(float)(vc->dst_rect.x1 - vc->dst_rect.x0);
+            int H = vo->dwidth;
+            int W = vo->dheight;
+            dstrect.w = W;
+            dstrect.h = H;
+            H = dstrect.h = (int)((vc->dst_rect.y1 - vc->dst_rect.y0)*scale);
+            dstrect.x = ((vo->dwidth - W) / 2 - 1);
+            dstrect.y = (W - H) / 2;
+        }else{
+            float scale = (float)vo->dwidth/(float)(vc->dst_rect.y1 - vc->dst_rect.y0);
+            int H = vo->dwidth;
+            dstrect.h = H;
+            int W = dstrect.w = (int)((vc->dst_rect.x1 - vc->dst_rect.y0)*scale);
+            dstrect.x = ((H - W) / 2 - 1);
+            dstrect.y = (W - H) / 2  + (vo->dheight - W)/2;
+        }
+        if (vc->display_orientation == SDL_ORIENTATION_LANDSCAPE){
+            //SDL_Log("SDL_ORIENTATION_LANDSCAPE\n");
+            SDL_RenderCopyEx(vc->renderer, vc->tex, NULL,  &dstrect, 270.0, NULL, SDL_FLIP_NONE);
+        }else{
+            //SDL_Log("SDL_ORIENTATION_LANDSCAPE_FLIPPED\n");
+            SDL_RenderCopyEx(vc->renderer, vc->tex, NULL,  &dstrect, 90.0, NULL, SDL_FLIP_NONE);
+        }
+    }else{
+        SDL_Rect src, dst;
+        src.x = vc->src_rect.x0;
+        src.y = vc->src_rect.y0;
+        src.w = vc->src_rect.x1 - vc->src_rect.x0;
+        src.h = vc->src_rect.y1 - vc->src_rect.y0;
+        dst.x = vc->dst_rect.x0;
+        dst.y = vc->dst_rect.y0;
+        dst.w = vc->dst_rect.x1 - vc->dst_rect.x0;
+        dst.h = vc->dst_rect.y1 - vc->dst_rect.y0;
+        if (vc->display_orientation == SDL_ORIENTATION_PORTRAIT){
+            //SDL_Log("SDL_ORIENTATION_PORTRAIT\n");
+            SDL_RenderCopy(vc->renderer, vc->tex, &src, &dst);
+        }else{
+            //SDL_Log("SDL_ORIENTATION_PORTRAIT_FLIPPED\n");
+            SDL_RenderCopyEx(vc->renderer, vc->tex, &src, &dst, 180.0, NULL, SDL_FLIP_NONE);
+        }
+    }
 
     draw_osd(vo);
 }
